import { OutputSuccess } from '../transform/types'
import elastic, { ElasticInputType } from './elastic'
import { name, typeDef } from './common'
const contractType = `
import { Validation } from "yaschva"

export type ContractType<T, K> = {
  name: string
  authentication: boolean | string[] |
  {
    get: boolean | string[]
    modify: boolean | string[]
    delete?: boolean | string[]
  } |
  {
    get: boolean | string[]
    post: boolean | string[]
    put: boolean | string[]
    patch: boolean | string[]
    delete: boolean | string[]
  }
  type: "get" | "post" | "put" | "patch" | "delete"
  handle?: (input: T) => Promise<K>
  arguments: Validation
  returns: Validation
}`

export const server = (contracts: OutputSuccess[]): string => {
  const valueDef = contracts.map(x => {
    let handle = 'undefined'
    if (x.preferredImplementation && x.preferredImplementation.type === 'elasticsearch') {
      let elin:ElasticInputType
      if (x.method === 'get') {
        elin = {
          idField: x.idFieldName,
          method: x.method,
          search: x.search || 'full'
        }
      } else {
        elin = {
          idField: x.idFieldName,
          method: x.method
        }
      }

      elastic(x.preferredImplementation, elin)
      const { index } = x.preferredImplementation
      const idField = x.idFieldName
      switch (x.method) {
        case 'get': {
          if (x.search === 'textSearch') { handle = `input => get("${index}", input && input.${idField}, input && input.search)` } else if (x.search === 'idOnly') { handle = `input => get("${index}", input && input.${idField})` } else if (x.search === 'full') { throw new Error('Parametric get not implemented yet') } else if (x.search) { throw new Error('Custom search is not supported with automatic elasticsearch methods') }
          break
        }
        case 'post':
          handle = `input => post("${index}", input, "${idField}")`
          break
        case 'patch':
          handle = `input => patch("${index}", input, input.${idField})`
          break
        case 'put':
          handle = `input => patch("${index}", input, input.${idField})`
          break
        case 'delete':
          handle = `input => del("${index}", input.${idField})`
          break
        default: // noop
      }
    }

    return `${name(x)}: {
          name: "${x.name}",
          authentication: ${JSON.stringify(x.authentication, undefined, 2)},
          type: "${x.method || 'get'}",
          handle: ${handle},
          arguments: ${JSON.stringify(x.arguments)} ,
          returns: ${JSON.stringify(x.returns)}}`
  }).join(',\n')

  const contractTypeList = contracts.map(x =>
    `${name(x)}: ContractType<${name(x)}Argument, ${name(x)}Returns>`).join('\n')

  const impl = [
    ...new Set(contracts.map(x => {
      if (!x.preferredImplementation) return undefined
      if (x.method === 'put') return 'patch'
      if (x.method === 'delete') return 'del'
      return x.method
    }).filter(x => x))
  ].join(',')
  const elasticImport = `import { ${impl} } from "../../communication/Elastic"`
  const result =
  `/**********************************************
   DO NOT EDIT THIS FILE, IT WILL BE OVERRIDDEN
***********************************************/
  ${contractType}
  ${impl ? elasticImport : ''}

  ${typeDef(contracts)}
  export type ContractListType = {\n${contractTypeList}\n}\n
  export const contracts: ContractListType = {\n${valueDef}\n}\n`

  return result
}

export default server
