// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Generate typing and fetch function for client Can set the import path for getToken function 1`] = `
"/* eslint-disable max-lines */
/**********************************************
  DO NOT EDIT THIS FILE, IT WILL BE OVERRIDDEN
***********************************************/

  import { validate, Validation } from \\"yaschva\\";
  import { deepFreeze, serialize } from \\"microtil\\";
  import getToken from \\"../myCustomTokenPath\\"
  const defaultHeader = async () => {
    const token = await getToken();
    const headers =  {
      'Authorization': \`Bearer \${token}\`,
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }

    if(!token) delete headers.Authorization
    return headers;
  };

    export const contracts: {[key:string]:{
      name:string, type:string, authentication:any,
      arguments: Validation, returns:Validation}} =
        deepFreeze({testGet: {
    name: \\"test\\",
    authentication: false,
    type: \\"get\\",
    arguments: {\\"myNumber\\":\\"number\\"},
    returns: {}}});

    /** test types for get method **/
export type testGetArgument = { myNumber: number }
export type testGetReturns = {  } | undefined

    export const testGet =
      async (input: testGetArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testGetReturns> => {

    const valid = validate(contracts.testGet.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\`/api/test?\${serialize(input || {})}\`, {
      method: \\"get\\",
      headers: await defaultHeader(),
      body: undefined,
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testGet.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

    export const functions = {testGet: testGet}
  "
`;

exports[`Generate typing and fetch function for client Generates crud example without an error that matches snapshot 1`] = `
"/* eslint-disable max-lines */
/**********************************************
  DO NOT EDIT THIS FILE, IT WILL BE OVERRIDDEN
***********************************************/

  import { validate, Validation } from \\"yaschva\\";
  import { deepFreeze, serialize } from \\"microtil\\";
  import getToken from \\"../getToken\\"
  const defaultHeader = async () => {
    const token = await getToken();
    const headers =  {
      'Authorization': \`Bearer \${token}\`,
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }

    if(!token) delete headers.Authorization
    return headers;
  };

    export const contracts: {[key:string]:{
      name:string, type:string, authentication:any,
      arguments: Validation, returns:Validation}} =
        deepFreeze({testGet: {
    name: \\"test\\",
    authentication: false,
    type: \\"get\\",
    arguments: {\\"search\\":[\\"string\\",\\"?\\"],\\"id\\":[\\"string\\",{\\"$array\\":\\"string\\"},\\"?\\"]},
    returns: {\\"$array\\":{\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}}},testPost: {
    name: \\"test\\",
    authentication: false,
    type: \\"post\\",
    arguments: {\\"id\\":[\\"string\\",\\"?\\"],\\"myNumber\\":\\"number\\"},
    returns: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}},testPut: {
    name: \\"test\\",
    authentication: false,
    type: \\"put\\",
    arguments: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"},
    returns: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}},testPatch: {
    name: \\"test\\",
    authentication: false,
    type: \\"patch\\",
    arguments: {\\"id\\":\\"string\\",\\"myNumber\\":[\\"number\\",\\"?\\"]},
    returns: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}},testDelete: {
    name: \\"test\\",
    authentication: false,
    type: \\"delete\\",
    arguments: {\\"id\\":[\\"string\\",{\\"$array\\":\\"string\\"}]},
    returns: {\\"$array\\":{\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}}}});

    /** test types for get method **/
export type testGetArgument = { search?: string | undefined; id?: string | string[] | undefined } | undefined
export type testGetReturns = { id: string; myNumber: number }[]

/** test types for post method **/
export type testPostArgument = { id?: string | undefined; myNumber: number }
export type testPostReturns = { id: string; myNumber: number }

/** test types for put method **/
export type testPutArgument = { id: string; myNumber: number }
export type testPutReturns = { id: string; myNumber: number }

/** test types for patch method **/
export type testPatchArgument = { id: string; myNumber?: number | undefined }
export type testPatchReturns = { id: string; myNumber: number }

/** test types for delete method **/
export type testDeleteArgument = { id: string | string[] }
export type testDeleteReturns = { id: string; myNumber: number }[]

    export const testGet =
      async (input: testGetArgument = {},
        signal: AbortSignal | undefined = undefined):
       Promise<testGetReturns> => {

    const valid = validate(contracts.testGet.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\`/api/test?\${serialize(input || {})}\`, {
      method: \\"get\\",
      headers: await defaultHeader(),
      body: undefined,
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testGet.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testPost =
      async (input: testPostArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testPostReturns> => {

    const valid = validate(contracts.testPost.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"post\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testPost.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testPut =
      async (input: testPutArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testPutReturns> => {

    const valid = validate(contracts.testPut.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"put\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testPut.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testPatch =
      async (input: testPatchArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testPatchReturns> => {

    const valid = validate(contracts.testPatch.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"patch\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testPatch.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testDelete =
      async (input: testDeleteArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testDeleteReturns> => {

    const valid = validate(contracts.testDelete.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"delete\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testDelete.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

    export const functions = {testGet: testGet,testPost: testPost,testPut: testPut,testPatch: testPatch,testDelete: testDelete}
  "
`;

exports[`Generate typing and fetch function for client Generates single example without an error that matches snapshot 1`] = `
"/* eslint-disable max-lines */
/**********************************************
  DO NOT EDIT THIS FILE, IT WILL BE OVERRIDDEN
***********************************************/

  import { validate, Validation } from \\"yaschva\\";
  import { deepFreeze, serialize } from \\"microtil\\";
  import getToken from \\"../getToken\\"
  const defaultHeader = async () => {
    const token = await getToken();
    const headers =  {
      'Authorization': \`Bearer \${token}\`,
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }

    if(!token) delete headers.Authorization
    return headers;
  };

    export const contracts: {[key:string]:{
      name:string, type:string, authentication:any,
      arguments: Validation, returns:Validation}} =
        deepFreeze({testGet: {
    name: \\"test\\",
    authentication: false,
    type: \\"get\\",
    arguments: {\\"myNumber\\":\\"number\\"},
    returns: {}}});

    /** test types for get method **/
export type testGetArgument = { myNumber: number }
export type testGetReturns = {  } | undefined

    export const testGet =
      async (input: testGetArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testGetReturns> => {

    const valid = validate(contracts.testGet.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\`/api/test?\${serialize(input || {})}\`, {
      method: \\"get\\",
      headers: await defaultHeader(),
      body: undefined,
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testGet.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

    export const functions = {testGet: testGet}
  "
`;
