// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Generate typing and fetch function for client Can set the import path for getToken function 1`] = `
"/* eslint-disable max-lines */
/**********************************************
  DO NOT EDIT THIS FILE, IT WILL BE OVERRIDDEN
***********************************************/

  import { validate, Validation } from \\"yaschva\\";
  import { deepFreeze, serialize } from \\"microtil\\";
  import getToken from \\"../myCustomTokenPath\\"
  const defaultHeader = async () => {
    const token = await getToken();
    const headers =  {
      'Authorization': \`Bearer \${token}\`,
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }

    if(!token) delete headers.Authorization
    return headers;
  };

    export const contracts: {[key:string]:{
      name:string, type:string, authentication:any,
      arguments: Validation, returns:Validation}} =
        deepFreeze({testGET: {
    name: \\"test\\",
    authentication: false,
    type: \\"GET\\",
    arguments: {\\"myNumber\\":\\"number\\"},
    returns: {}}});

    /** test types for GET method **/
export type testGETArgument = { myNumber: number }
export type testGETReturns = {  } | undefined

    export const testGET =
      async (input: testGETArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testGETReturns> => {

    const valid = validate(contracts.testGET.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\`/api/test?\${serialize(input || {})}\`, {
      method: \\"GET\\",
      headers: await defaultHeader(),
      body: undefined,
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testGET.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

    export const functions = {testGET: testGET}
  "
`;

exports[`Generate typing and fetch function for client Generates crud example without an error that matches snapshot 1`] = `
"/* eslint-disable max-lines */
/**********************************************
  DO NOT EDIT THIS FILE, IT WILL BE OVERRIDDEN
***********************************************/

  import { validate, Validation } from \\"yaschva\\";
  import { deepFreeze, serialize } from \\"microtil\\";
  import getToken from \\"../getToken\\"
  const defaultHeader = async () => {
    const token = await getToken();
    const headers =  {
      'Authorization': \`Bearer \${token}\`,
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }

    if(!token) delete headers.Authorization
    return headers;
  };

    export const contracts: {[key:string]:{
      name:string, type:string, authentication:any,
      arguments: Validation, returns:Validation}} =
        deepFreeze({testGET: {
    name: \\"test\\",
    authentication: false,
    type: \\"GET\\",
    arguments: {\\"search\\":[\\"string\\",\\"?\\"],\\"id\\":[\\"string\\",{\\"$array\\":\\"string\\"},\\"?\\"]},
    returns: {\\"$array\\":{\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}}},testPOST: {
    name: \\"test\\",
    authentication: false,
    type: \\"POST\\",
    arguments: {\\"id\\":[\\"string\\",\\"?\\"],\\"myNumber\\":\\"number\\"},
    returns: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}},testPUT: {
    name: \\"test\\",
    authentication: false,
    type: \\"PUT\\",
    arguments: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"},
    returns: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}},testPATCH: {
    name: \\"test\\",
    authentication: false,
    type: \\"PATCH\\",
    arguments: {\\"id\\":\\"string\\",\\"myNumber\\":[\\"number\\",\\"?\\"]},
    returns: {\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}},testDELETE: {
    name: \\"test\\",
    authentication: false,
    type: \\"DELETE\\",
    arguments: {\\"id\\":[\\"string\\",{\\"$array\\":\\"string\\"}]},
    returns: {\\"$array\\":{\\"id\\":\\"string\\",\\"myNumber\\":\\"number\\"}}}});

    /** test types for GET method **/
export type testGETArgument = { search?: string | undefined; id?: string | string[] | undefined } | undefined
export type testGETReturns = { id: string; myNumber: number }[]

/** test types for POST method **/
export type testPOSTArgument = { id?: string | undefined; myNumber: number }
export type testPOSTReturns = { id: string; myNumber: number }

/** test types for PUT method **/
export type testPUTArgument = { id: string; myNumber: number }
export type testPUTReturns = { id: string; myNumber: number }

/** test types for PATCH method **/
export type testPATCHArgument = { id: string; myNumber?: number | undefined }
export type testPATCHReturns = { id: string; myNumber: number }

/** test types for DELETE method **/
export type testDELETEArgument = { id: string | string[] }
export type testDELETEReturns = { id: string; myNumber: number }[]

    export const testGET =
      async (input: testGETArgument = {},
        signal: AbortSignal | undefined = undefined):
       Promise<testGETReturns> => {

    const valid = validate(contracts.testGET.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\`/api/test?\${serialize(input || {})}\`, {
      method: \\"GET\\",
      headers: await defaultHeader(),
      body: undefined,
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testGET.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testPOST =
      async (input: testPOSTArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testPOSTReturns> => {

    const valid = validate(contracts.testPOST.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"POST\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testPOST.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testPUT =
      async (input: testPUTArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testPUTReturns> => {

    const valid = validate(contracts.testPUT.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"PUT\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testPUT.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testPATCH =
      async (input: testPATCHArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testPATCHReturns> => {

    const valid = validate(contracts.testPATCH.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"PATCH\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testPATCH.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

export const testDELETE =
      async (input: testDELETEArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testDELETEReturns> => {

    const valid = validate(contracts.testDELETE.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\\"/api/test\\", {
      method: \\"DELETE\\",
      headers: await defaultHeader(),
      body: JSON.stringify(input),
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testDELETE.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

    export const functions = {testGET: testGET,testPOST: testPOST,testPUT: testPUT,testPATCH: testPATCH,testDELETE: testDELETE}
  "
`;

exports[`Generate typing and fetch function for client Generates single example without an error that matches snapshot 1`] = `
"/* eslint-disable max-lines */
/**********************************************
  DO NOT EDIT THIS FILE, IT WILL BE OVERRIDDEN
***********************************************/

  import { validate, Validation } from \\"yaschva\\";
  import { deepFreeze, serialize } from \\"microtil\\";
  import getToken from \\"../getToken\\"
  const defaultHeader = async () => {
    const token = await getToken();
    const headers =  {
      'Authorization': \`Bearer \${token}\`,
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }

    if(!token) delete headers.Authorization
    return headers;
  };

    export const contracts: {[key:string]:{
      name:string, type:string, authentication:any,
      arguments: Validation, returns:Validation}} =
        deepFreeze({testGET: {
    name: \\"test\\",
    authentication: false,
    type: \\"GET\\",
    arguments: {\\"myNumber\\":\\"number\\"},
    returns: {}}});

    /** test types for GET method **/
export type testGETArgument = { myNumber: number }
export type testGETReturns = {  } | undefined

    export const testGET =
      async (input: testGETArgument,
        signal: AbortSignal | undefined = undefined):
       Promise<testGETReturns> => {

    const valid = validate(contracts.testGET.arguments, input);
      if (valid.result === \\"fail\\") throw valid;
    return fetch(\`/api/test?\${serialize(input || {})}\`, {
      method: \\"GET\\",
      headers: await defaultHeader(),
      body: undefined,
      signal
    }).then(x=> x.json())
    .then(x=> {
      if(x.errorType){throw x}
      const r = validate(contracts.testGET.returns, x);
      if(r.result ===\\"fail\\") throw r; return x})
};

    export const functions = {testGET: testGET}
  "
`;
